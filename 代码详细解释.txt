nm-dpos/
├── types/
│   ├── node.go              # 节点数据结构
│   ├── network.go           # 网络数据结构
│   └── records.go           # 记录数据结构
│
├── core/
│   ├── decay.go             # 权重衰减算法
│   ├── scheduler.go         # 出块调度器
│   ├── performance.go       # 节点表现评估
│   ├── voting.go            # 动态投票机制
│   └── reward.go            # 奖励分配算法
│
├── network/
│   ├── communication.go     # 区块和交易池
│   ├── local_view.go        # 本地网络视图
│   └── sync.go              # 区块同步
│
├── p2p/                     # P2P 网络层
│   ├── discovery.go         # 节点发现
│   ├── peer.go              # 对等节点管理
│   ├── transport.go         # 网络传输（HTTP/WebSocket）
│
├── node/
│   └──p2p_node.go           # P2P 独立节点
│
├── test/
│   └── network_test.go      # 测试用
│
├── config/
│   └── constants.go          # 全局常量
│
└── utils/
│   ├── math.go                # 数学工具
│   └── logger.go              # 日志工具
└── cmd/
│    └── seed/
│        └── main.go           # 种子节点程序,启动入口
├── scripts/
│   ├── start_network.sh        启动脚本
│   └── stop_network.sh         停止脚本
├── go.mod
└── README.md                   文档

项目结构
nm-dpos/
├── config/          # 配置
├── types/           # 数据结构
├── core/            # 核心算法
├── network/         # 网络管理
├── p2p/             # P2P网络
├── node/            # 独立节点
├── test/            # 模拟测试框架
├── utils/           # 工具函数
├── cmd/seed/        # 种子节点
└── scripts/         # 测试脚本




# 完整流程图

┌─────────────────────────────────────────────────────────────┐
│                    main.go 启动流程                          │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
              ┌───────────────────────┐
              │  1. 解析命令行参数     │
              │  - nodeID, listen      │
              │  - weight, perf       │
              │  - seeds, test        │
              └───────────────────────┘
                          │
                          ▼
              ┌───────────────────────┐
              │  2. 创建Logger         │
              │  logger := utils.      │
              │    NewLogger(nodeID)   │
              └───────────────────────┘
                          │
                          ▼
    ┌─────────────────────────────────────────────────┐
    │  3. 创建P2PNode (node.NewP2PNode)                │
    │                                                  │
    │  ┌────────────────────────────────────────┐    │
    │  │ 3.1 创建本地节点 (types.NewNode)       │    │
    │  │   - InitialWeight = weight             │    │
    │  │   - PerformanceScore = perf            │    │
    │  │   - NetworkDelay = delay               │    │
    │  └────────────────────────────────────────┘    │
    │                   │                             │
    │                   ▼                             │
    │  ┌────────────────────────────────────────┐    │
    │  │ 3.2 创建LocalNetworkView                │    │
    │  │   ├─ Network结构(types.Network)         │    │
    │  │   ├─ TxPool(交易池)                     │    │
    │  │   ├─ BlockPool(区块池)                  │    │
    │  │   └─ SyncManager(同步管理器)            │    │
    │  └────────────────────────────────────────┘    │
    │                   │                             │
    │                   ▼                             │
    │  ┌────────────────────────────────────────┐    │
    │  │ 3.3 创建P2P组件                         │    │
    │  │   ├─ PeerManager(节点管理)              │    │
    │  │   ├─ HTTPTransport(传输层)              │    │
    │  │   └─ DiscoveryService(节点发现)         │    │
    │  └────────────────────────────────────────┘    │
    └─────────────────────────────────────────────────┘
                          │
                          ▼
         ┌────────────────────────────────────┐
         │  4. 启动节点 (p2pNode.Start)        │
         │                                     │
         │  ┌──────────────────────────────┐  │
         │  │ 4.1 启动HTTP服务器            │  │
         │  │   - 注册路由处理器            │  │
         │  │   - /vote, /block, /sync...  │  │
         │  └──────────────────────────────┘  │
         │            │                        │
         │            ▼                        │
         │  ┌──────────────────────────────┐  │
         │  │ 4.2 启动节点发现              │  │
         │  │   - 连接种子节点              │  │
         │  │   - 定期刷新节点列表          │  │
         │  │   - 广播自己的存在            │  │
         │  └──────────────────────────────┘  │
         │            │                        │
         │            ▼                        │
         │  ┌──────────────────────────────┐  │
         │  │ 4.3 启动同步管理器            │  │
         │  │   - 定期清理超时请求          │  │
         │  └──────────────────────────────┘  │
         │            │                        │
         │            ▼                        │
         │  ┌──────────────────────────────┐  │
         │  │ 4.4 启动主循环(mainLoop)      │  │
         │  │   - roundTicker(共识轮次)     │  │
         │  │   - syncTicker(同步检查)      │  │
         │  └──────────────────────────────┘  │
         └────────────────────────────────────┘
                          │
                          ▼
    ┌───────────────────────────────────────────────┐
    │  5. 主循环 - 每个区块周期执行一次               │
    │     (每3秒一轮，config.BlockInterval)          │
    │                                                │
    │  ┌──────────────────────────────────────┐    │
    │  │ 5.1 同步网络状态(syncPeerStates)      │    │
    │  │   - 向所有peer请求状态                │    │
    │  │   - 更新本地视图                      │    │
    │  └──────────────────────────────────────┘    │
    │               │                               │
    │               ▼                               │
    │  ┌──────────────────────────────────────┐    │
    │  │ 5.2 更新权重(updateWeight)            │    │
    │  │   ✅ 调用 core/decay.go              │    │
    │  │   ✅ 实现牛顿冷却公式(第2章)         │    │
    │  │   W(t) = W(0) * e^[-c*(1-R)*t]       │    │
    │  └──────────────────────────────────────┘    │
    │               │                               │
    │               ▼                               │
    │  ┌──────────────────────────────────────┐    │
    │  │ 5.3 选举代理节点                      │    │
    │  │   (SelectDelegatesLocally)            │    │
    │  │   - 按权重排序                        │    │
    │  │   - 选出前N个节点                     │    │
    │  └──────────────────────────────────────┘    │
    │               │                               │
    │               ▼                               │
    │  ┌──────────────────────────────────────┐    │
    │  │ 5.4 投票阶段(如果是投票节点)          │    │
    │  │   ✅ 调用 core/voting.go             │    │
    │  │                                       │    │
    │  │   ┌────────────────────────────┐     │    │
    │  │   │ a. 正常投票区段(第4.2节)   │     │    │
    │  │   │  - 动态计算投票时间         │     │    │
    │  │   │  - 选择投票目标             │     │    │
    │  │   │  - 发送投票消息             │     │    │
    │  │   └────────────────────────────┘     │    │
    │  │               │                       │    │
    │  │               ▼                       │    │
    │  │   ┌────────────────────────────┐     │    │
    │  │   │ b. 代投阶段(第4.3节)        │     │    │
    │  │   │  - 为超时节点代投           │     │    │
    │  │   │  - 计算代投补偿             │     │    │
    │  │   └────────────────────────────┘     │    │
    │  │               │                       │    │
    │  │               ▼                       │    │
    │  │   ┌────────────────────────────┐     │    │
    │  │   │ c. 失败处理(第4.4节)        │     │    │
    │  │   │  - 惩罚超时节点             │     │    │
    │  │   │  - 扣除权重和保证金         │     │    │
    │  │   └────────────────────────────┘     │    │
    │  │               │                       │    │
    │  │               ▼                       │    │
    │  │   ┌────────────────────────────┐     │    │
    │  │   │ d. 热补偿分配(第5.2节)      │     │    │
    │  │   │  - 收集失败节点流出权重     │     │    │
    │  │   │  - 按比例分配给成功节点     │     │    │
    │  │   └────────────────────────────┘     │    │
    │  └──────────────────────────────────────┘    │
    │               │                               │
    │               ▼                               │
    │  ┌──────────────────────────────────────┐    │
    │  │ 5.5 出块阶段(如果是代理节点)          │    │
    │  │   (produceBlock)                      │    │
    │  │   - 从交易池获取交易                  │    │
    │  │   - 创建区块                          │    │
    │  │   - 广播区块                          │    │
    │  │   - 记录出块结果(第3.2.1节)           │    │
    │  └──────────────────────────────────────┘    │
    │               │                               │
    │               ▼                               │
    │  ┌──────────────────────────────────────┐    │
    │  │ 5.6 更新表现评分                      │    │
    │  │   ✅ 调用 core/performance.go        │    │
    │  │                                       │    │
    │  │   投票节点:                           │    │
    │  │   R_i = α*V_i + β*B_i + γ*E_j        │    │
    │  │                                       │    │
    │  │   代理节点:                           │    │
    │  │   E_j = α*P_j + β*C_j + γ*O_j        │    │
    │  └──────────────────────────────────────┘    │
    │               │                               │
    │               ▼                               │
    │  ┌──────────────────────────────────────┐    │
    │  │ 5.7 广播状态(broadcastStatus)         │    │
    │  │   - 向所有peer发送状态更新            │    │
    │  └──────────────────────────────────────┘    │
    └───────────────────────────────────────────────┘
                          │
                          ▼
         ┌────────────────────────────────────┐
         │ 6. 测试模式 (可选, -test=true)      │
         │                                     │
         │  ┌──────────────────────────────┐  │
         │  │ 6.1 等待网络稳定(5秒)         │  │
         │  └──────────────────────────────┘  │
         │            │                        │
         │            ▼                        │
         │  ┌──────────────────────────────┐  │
         │  │ 6.2 运行测试                  │  │
         │  │   (test.RunFullTest)          │  │
         │  │   - 记录每轮数据              │  │
         │  │   - 保存到CSV                │  │
         │  │   - 生成分析报告              │  │
         │  └──────────────────────────────┘  │
         └────────────────────────────────────┘
                          │
                          ▼
              ┌───────────────────────┐
              │ 7. 等待停止信号        │
              │   (Ctrl+C)            │
              └───────────────────────┘


种子节点机制的连接逻辑

第一阶段：其他节点连接种子节点
┌─────────┐      ┌─────────┐
│ Node-1  │─────>│ Node-0  │ (种子节点)
└─────────┘      │(Seed)   │
                 └─────────┘
┌─────────┐           ^
│ Node-2  │───────────┘
└─────────┘
┌─────────┐
│ Node-3  │───────────┐
└─────────┘           v
                 ┌─────────┐
┌─────────┐      │ Node-0  │
│ Node-4  │─────>│(Seed)   │
└─────────┘      └─────────┘

第二阶段：种子节点返回已知对等列表
                 ┌─────────┐
        ┌────────│ Node-0  │────────┐
        │        │(Seed)   │        │
        │        └─────────┘        │
        │  peers: [N1,N2,N3,N4]    │
        v                            v
┌─────────┐                    ┌─────────┐
│ Node-1  │<───────────────────│ Node-2  │
└─────────┘  从N0获得N2地址    └─────────┘
    │        主动连接N2             │
    └───────────────────────────────┘

第三阶段：节点间互相发现（网状拓扑）
┌─────────┐    ┌─────────┐    ┌─────────┐
│ Node-1  │────│ Node-2  │────│ Node-3  │
└─────────┘    └─────────┘    └─────────┘
     │              │              │
     └──────────────┼──────────────┘
                    │
               ┌─────────┐
               │ Node-4  │
               └─────────┘




核心算法调用链
1 权重衰减流程 (第2章)
mainLoop (每轮)
  └─> updateWeight()  [node/p2p_node.go]
       └─> LocalView.UpdateLocalWeight()  [network/local_view.go]
            └─> core.UpdateNodeWeight()  [core/decay.go]
                 ├─> CalculateDecayRate(R_i)
                 │    └─> λ = c * (1 - R_i)
                 │
                 └─> utils.NewtonCooling(W_0, W_env, λ, t)
                      └─> W(t) = W_env + (W_0 - W_env) * e^(-λ*t)


代码路径:
// 1. node/p2p_node.go:421
func (pn *P2PNode) updateWeight() {
    pn.LocalView.UpdateLocalWeight()
    // ...
}

// 2. network/local_view.go:155
func (lnv *LocalNetworkView) UpdateLocalWeight() {
    core.UpdateNodeWeight(lnv.LocalNode, 1.0, lnv.EnvironmentWeight)
}

// 3. core/decay.go:18 (核心算法)
func UpdateNodeWeight(node *types.Node, timePeriods, envWeight float64) float64 {
    decayRate := CalculateDecayRate(node.PerformanceScore)
    newWeight := utils.NewtonCooling(
        node.InitialWeight,
        envWeight,
        decayRate,
        timePeriods,
    )
    node.CurrentWeight = newWeight
    return newWeight
}

2 表现评估流程 (第3章)
mainLoop (每轮)
  └─> updatePerformance()  [node/p2p_node.go]
       └─> LocalView.UpdateLocalPerformance()  [network/local_view.go]
            │
            ├─> [投票节点] core.UpdateVoterPerformance()
            │    └─> R_i = α*V_i + β*B_i + γ*E_j
            │         ├─> V_i: CalculateVotingSpeed()
            │         ├─> B_i: CalculateVotingBehavior()
            │         └─> E_j: 代理节点平均表现
            │
            └─> [代理节点] core.UpdateDelegatePerformance()
                 └─> E_j = α*P_j + β*C_j + γ*O_j
                      ├─> P_j: CalculateBlockEfficiency()
                      ├─> C_j: CalculateValidationEfficiency()
                      └─> O_j: CalculateOnlineScore()

3 投票机制流程 (第4章)
mainLoop (每轮)
  └─> vote()  [node/p2p_node.go]
       │
       ├─> LocalView.GetVotingTarget()  [选择投票目标]
       │
       └─> sendVoteMessage()  [发送HTTP请求]
            │
            ▼
       [目标节点接收] handleVoteRequest()
            │
            └─> 记录投票权重

---并行执行---

LocalView.ConductLocalVoting()  [本地投票会话]
  └─> core.NewVotingSession()
       │
       ├─> CalculateNormalVotingPeriod()  [第4.2节]
       │    └─> T_normal = T_base * (1+ΣD/(n*D_s)) * ln(1+N_vote/N_all)
       │
       ├─> ConductVoting()  [第4章主流程]
       │    ├─> conductNormalVoting()  [正常投票]
       │    ├─> conductProxyVoting()   [代投, 第4.3节]
       │    └─> handleVotingFailures() [失败处理, 第4.4节]
       │
       └─> DistributeHotCompensation()  [第5.2节]
            └─> 按权重比例分配补偿池



4 出块流程 (第3.2节)
mainLoop (每轮)
  └─> produceBlock()  [node/p2p_node.go]
       │
       ├─> TxPool.GetPendingTransactions()  [获取交易]
       │
       ├─> 创建Block结构
       │    ├─> Height = 前一个块高度 + 1
       │    ├─> ProducerID = 本节点ID
       │    └─> Hash = 计算哈希
       │
       ├─> BlockPool.AddBlock()  [添加到本地]
       │
       ├─> broadcastBlock()  [广播给所有peer]
       │    └─> HTTP POST /block
       │
       └─> core.RecordBlockProduction()  [记录出块结果]
            └─> 更新ValidBlocks/DelayedBlocks/InvalidBlocks

5 同步流程 (完整P2P)
[节点A] checkSync()  (每10秒)
  └─> SyncManager.CheckAndSync()
       │
       ├─> 检测本地高度落后
       │
       └─> RequestSync()
            └─> HTTP POST /sync_request
                 │
                 ▼
            [节点B] handleSyncRequestMessage()
                 │
                 ├─> BlockPool.GetBlockRange()
                 │
                 └─> HTTP Response (blocks)
                      │
                      ▼
            [节点A] handleSyncResponseMessage()
                 │
                 ├─> 验证区块
                 ├─> BlockPool.AddBlock()
                 │
                 └─> 如果hasMore, 继续请求

6 测试方案体现
典型节点场景 (文档2.4节表格)
脚本: scripts/start_network.sh
# 节点0: H-G (高权重优秀)
./bin/nm-dpos -id="node-0" -weight=150 -perf=0.95 -delay=10 -time=""

# 节点1: H-M (高权重良好)
./bin/nm-dpos -id="node-1" -weight=150 -perf=0.70 -delay=20 -time=""

# 节点2: H-B (高权重差劲)
./bin/nm-dpos -id="node-2" -weight=150 -perf=0.30 -delay=30 -time=""

# 节点3: L-G (低权重优秀)
./bin/nm-dpos -id="node-3" -weight=50 -perf=0.95 -delay=15 -time=""

# 节点4: L-M (低权重良好)
./bin/nm-dpos -id="node-4" -weight=50 -perf=0.70 -delay=25 -time=""



对比:
标准 DPoS 流程：
第一阶段：选举代理节点（每个周期）
┌────────────────────────────────────────┐
│ 所有节点投票 → 选出前N个代理节点        │
│ 例如：选出21个代理节点                  │
└────────────────────────────────────────┘

第二阶段：代理节点轮流出块（每3秒一个块）
┌────────────────────────────────────────┐
│ 时间槽分配：                            │
│   Slot 0: Delegate-0 出块              │
│   Slot 1: Delegate-1 出块              │
│   Slot 2: Delegate-2 出块              │
│   ...                                  │
│   Slot 20: Delegate-20 出块            │
│   Slot 21: Delegate-0 出块 (循环)      │
└────────────────────────────────────────┘

一个完整的轮次 = 所有代理节点各出一个块

改进方案的出块机制:
记录每个代理节点的出块质量
根据出块表现计算代理节点评分 E_j
E_j 影响节点权重衰减速度
表现差的节点更快被淘汰


投票阶段
完整流程:

1. 投票阶段
   ├─ 锁定保证金（所有活跃节点(包括代理节点)锁定保证金）
   ├─ 发送投票 （正常投票区段: 所有节点(包括代理)向代理节点投票）
   ├─ 代投处理 （代投区段: 快速节点帮慢速节点代投）
   ├─ 失败惩罚 （未投票节点惩罚）
   ├─ 热补偿(此时不处理保证金)
   └─ 按DelegatedWeight排序,选前N个（统计委托权重,选出代理节点）


2. 出块阶段
   ├─ 代理节点轮流出块
   ├─ 记录出块状态(成功/失败)
   └─ 广播出块状态 ✅

3. 等待出块状态同步
   └─ time.Sleep(500ms)

4. 处理投票结果 ✅处理保证金和热补偿
   ├─ 情况A: 未投票 → 已在投票阶段处理（扣权重+没收保证金）
   ├─ 情况B: 投票但未当选 → 退回保证金
   ├─ 情况C: 投票且出块成功 → 退回保证金 + 热补偿
   └─ 情况D: 投票但出块失败 → 部分扣除保证金

5. Shapley值分配出块收益（ 投票给成功出块代理的节点获得奖励）

5. 更新表现评分

6. 广播状态

